class Solution {
    public boolean isValid(String s) {
        /*the easy way to solve this problem is to iterate from both sides and make sure that the count */
        /*generally speaking the hard thing about this problem is being able to get past the order part*/

        /*store in some kind of dynamic array list what the next closed parenthese must be - if not the same return false */

        boolean answer = false;
        int numCurly = 0;
        int numNormal = 0;
        int numStraight = 0;
        ArrayList<Character> lastVals = new ArrayList<>();
        lastVals.add('p');

        for(int i=0; i<s.length();i++){
            char val = s.charAt(i);
            char last = lastVals.get(lastVals.size() - 1);
            if(val =='{'){
                numCurly++;
                lastVals.add(val);
            } else if (val == '('){
                numNormal++;
                lastVals.add(val);
            } else if (val == '['){
                numStraight++;
                lastVals.add(val);
            } else if(val == ']'){
                numStraight--;
                if(last != '['){
                    return false;
                }
                lastVals.remove(lastVals.size() - 1);
            } else if(val == ')'){
                numNormal--;
                if(last != '('){
                    return false;
                }
                lastVals.remove(lastVals.size() - 1);
            } else if(val == '}'){
                numCurly--;
                if(last != '{'){
                    return false;
                }
                lastVals.remove(lastVals.size() - 1);
            }
        }

        if(numCurly == 0 && numNormal == 0 && numStraight == 0){
            answer = true;
            return answer;
        } else {
            return answer;
        }

    }
}
